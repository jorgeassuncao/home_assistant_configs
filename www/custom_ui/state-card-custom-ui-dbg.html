<div hidden="" by-polymer-bundler=""><script>
window.customUI = window.customUI || {
  VERSION: '20180126',

  SUPPORTED_SLIDER_MODES: [
    'single-line', 'break-slider', 'break-slider-toggle', 'hide-slider', 'no-slider',
  ],

  domHost(elem) {
    if (elem === document) return null;
    const root = elem.getRootNode();
    return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;
  },

  lightOrShadow(elem, selector) {
    return elem.shadowRoot ?
      elem.shadowRoot.querySelector(selector) :
      elem.querySelector(selector);
  },

  getElementHierarchy(root, hierarchy) {
    if (root === null) return null;
    const elem = hierarchy.shift();
    if (elem) {
      return window.customUI.getElementHierarchy(
        window.customUI.lightOrShadow(root, elem), hierarchy);
    }
    return root;
  },

  getContext(elem) {
    if (elem._context === undefined) {
      elem._context = [];
      for (let element = (elem.tagName === 'HA-ENTITIES-CARD' ? window.customUI.domHost(elem) : elem);
        element; element = window.customUI.domHost(element)) {
        switch (element.tagName) {
          case 'HA-ENTITIES-CARD':
            if (element.groupEntity) {
              elem._context.push(element.groupEntity.entity_id);
            } else if (element.groupEntity === false && element.states && element.states.length) {
              elem._context.push(`group.${window.hassUtil.computeDomain(element.states[0])}`);
            }
            break;
          case 'MORE-INFO-GROUP':
          case 'STATE-CARD-CONTENT':
            if (element.stateObj) {
              elem._context.push(element.stateObj.entity_id);
            }
            break;
          case 'HA-CARDS':
            elem._context.push(element.getAttribute('data-view') || 'default_view');
            break;
          // no default
        }
      }
      elem._context.reverse();
    }
    return elem._context;
  },

  findMatch(key, options) {
    if (!options) return null;
    if (options[key]) return key;
    return Object.keys(options).find(option => key.match(`^${option}$`));
  },

  maybeChangeObjectByDevice(stateObj) {
    const name = window.customUI.getName();
    if (!name) return stateObj;
    const match = this.findMatch(name, stateObj.attributes.device);
    if (!match) return stateObj;
    const attributes = Object.assign({}, stateObj.attributes.device[match]);

    if (!Object.keys(attributes).length) return stateObj;
    return window.customUI.applyAttributes(stateObj, attributes);
  },

  maybeChangeObjectByGroup(elem, stateObj) {
    const context = window.customUI.getContext(elem);
    if (!context) return stateObj;

    if (!stateObj.attributes.group) {
      return stateObj;
    }
    const attributes = {};
    context.forEach((c) => {
      const match = this.findMatch(c, stateObj.attributes.group);
      if (stateObj.attributes.group[match]) {
        Object.assign(attributes, stateObj.attributes.group[match]);
      }
    });

    if (!Object.keys(attributes).length) return stateObj;

    return window.customUI.applyAttributes(stateObj, attributes);
  },

  _setKeep(obj, value) {
    if (obj._cui_keep === undefined) {
      obj._cui_keep = value;
    } else {
      obj._cui_keep = obj._cui_keep && value;
    }
  },

  maybeApplyTemplateAttributes(hass, states, stateObj, attributes) {
    if (!attributes.templates) {
      window.customUI._setKeep(stateObj, true);
      return stateObj;
    }
    const newAttributes = {};
    let hasGlobal = false;
    let hasChanges = false;
    Object.keys(attributes.templates).forEach((key) => {
      const template = attributes.templates[key];
      if (template.match(/\b(entities|hass)\b/)) {
        hasGlobal = true;
      }
      const value = window.customUI.computeTemplate(
        template, hass, states, stateObj, attributes,
        attributes[key], stateObj.state);
      newAttributes[key] = value;
      if (key === 'state') {
        if (value !== stateObj.state) {
          hasChanges = true;
        }
      } else if (key === '_stateDisplay') {
        if (value !== stateObj._stateDisplay) {
          hasChanges = true;
        }
      } else if (value !== attributes[key]) {
        hasChanges = true;
      }
    });
    window.customUI._setKeep(stateObj, !hasGlobal);
    if (!hasChanges) {
      return stateObj;
    }
    if (stateObj.attributes === attributes) {
      // We are operating on real attributes. Replace them.
      const result = window.customUI.applyAttributes(stateObj, newAttributes);
      if (Object.prototype.hasOwnProperty.call(newAttributes, 'state')) {
        result.state = newAttributes.state;
      }
      if (Object.prototype.hasOwnProperty.call(newAttributes, '_stateDisplay')) {
        result._stateDisplay = newAttributes._stateDisplay;
      }
      window.customUI._setKeep(result, !hasGlobal);
      return result;
    }
    // Operating on context-aware attributes. Return shallow copy of object.
    return Object.assign({}, stateObj);
  },

  maybeApplyTemplates(hass, states, stateObj) {
    const newResult = window.customUI.maybeApplyTemplateAttributes(
      hass, states, stateObj, stateObj.attributes);
    let hasChanges = (newResult !== stateObj);

    function checkAttributes(obj) {
      if (!obj) return;
      Object.values(obj).forEach((attributes) => {
        const result = window.customUI.maybeApplyTemplateAttributes(
          hass, states, newResult, attributes);
        hasChanges |= (result !== newResult);
      });
      checkAttributes(obj.device);
      checkAttributes(obj.group);
    }

    checkAttributes(stateObj.attributes.device);
    checkAttributes(stateObj.attributes.group);
    if (newResult !== stateObj) return newResult;
    if (hasChanges) {
      return Object.assign({}, stateObj);
    }
    return stateObj;
  },

  applyAttributes(stateObj, attributes) {
    return {
      entity_id: stateObj.entity_id,
      state: stateObj.state,
      attributes: Object.assign({}, stateObj.attributes, attributes),
      last_changed: stateObj.last_changed,
    };
  },

  maybeChangeObject(elem, stateObj, inDialog, allowHidden) {
    if (inDialog) return stateObj;
    let obj = window.customUI.maybeChangeObjectByDevice(stateObj);
    obj = window.customUI.maybeChangeObjectByGroup(elem, obj);
    obj = window.customUI.maybeApplyTemplateAttributes(
      elem.hass, elem.hass.states, obj, obj.attributes);

    if (obj !== stateObj && obj.attributes.hidden && allowHidden) {
      return null;
    }
    return obj;
  },

  fixGroupTitles() {
    const homeAssistantMain = window.customUI.getElementHierarchy(document, [
      'home-assistant',
      'home-assistant-main']);
    if (homeAssistantMain === null) {
      // DOM not ready. Wait 1 second.
      window.setTimeout(window.customUI.fixGroupTitles, 1000);
      return;
    }

    const haCards = window.customUI.getElementHierarchy(homeAssistantMain, [
      'partial-cards',
      'ha-cards[view-visible]']);
    if (haCards === null) return;
    const main = window.customUI.lightOrShadow(haCards, '.main') || haCards.$.main;
    const cards = main.querySelectorAll('ha-entities-card');
    cards.forEach((card) => {
      if (card.groupEntity) {
        const obj = window.customUI.maybeChangeObject(
          card,
          card.groupEntity,
          false /* inDialog */,
          false /* allowHidden */);
        if (obj !== card.groupEntity && obj.attributes.friendly_name) {
          const nameElem = window.customUI.lightOrShadow(card, '.name');
          nameElem.textContent = obj.attributes.friendly_name;
        }
      }
    });
  },

  showVersion() {
    if (window.location.pathname !== '/dev-info') return;
    const devInfo = window.customUI.getElementHierarchy(document, [
      'home-assistant',
      'home-assistant-main',
      'partial-panel-resolver',
      'ha-panel-dev-info']);
    if (devInfo === null) {
      // DOM not ready. Wait 1 second.
      window.setTimeout(window.customUI.showVersion, 1000);
      return;
    }
    const about = window.customUI.lightOrShadow(devInfo, '.about');
    const secondP = about.querySelectorAll('p')[1];
    const version = document.createElement('p');
    version.textContent = `Custom UI ${window.customUI.VERSION}`;
    about.insertBefore(version, secondP);
  },

  controlColumns(columns) {
    const partialCards = window.customUI.getElementHierarchy(document, [
      'home-assistant',
      'home-assistant-main',
      'partial-cards']);
    if (partialCards === null) {
      // DOM not ready. Wait 1 second.
      window.setTimeout(
        window.customUI.controlColumns.bind(null, columns),
        1000);
      return;
    }
    partialCards.mqls.forEach((mql) => {
      mql.removeListener(partialCards.handleWindowChange);
    });
    partialCards.mqls = columns.map((width) => {
      const mql = window.matchMedia(`(min-width: ${width}px)`);
      mql.addListener(partialCards.handleWindowChange);
      return mql;
    });
    partialCards.handleWindowChange();
  },

  useCustomizer() {
    const main = window.customUI.lightOrShadow(document, 'home-assistant');
    const customizer = main.hass.states['customizer.customizer'];
    if (!customizer) return;
    if (customizer.attributes.columns) {
      window.customUI.controlColumns(customizer.attributes.columns);
    }

    if (customizer.attributes.hide_attributes) {
      if (window.hassUtil.LOGIC_STATE_ATTRIBUTES) {
        Array.prototype.push.apply(
          window.hassUtil.LOGIC_STATE_ATTRIBUTES, customizer.attributes.hide_attributes);
      }
      if (window.hassAttributeUtil.LOGIC_STATE_ATTRIBUTES) {
        customizer.attributes.hide_attributes.forEach((attr) => {
          if (!Object.prototype.hasOwnProperty.call(
            window.hassAttributeUtil.LOGIC_STATE_ATTRIBUTES, attr)) {
            window.hassAttributeUtil.LOGIC_STATE_ATTRIBUTES[attr] = undefined;
          }
        });
      }
    }
  },

  updateAttributes() {
    const customUiAttributes = {
      group: undefined,
      device: undefined,
      templates: undefined,
      state_card_mode: {
        type: 'array',
        options: {
          light: window.customUI.SUPPORTED_SLIDER_MODES.concat('badges'),
          cover: window.customUI.SUPPORTED_SLIDER_MODES.concat('badges'),
          '*': ['badges'],
        },
      },
      state_card_custom_ui_secondary: { type: 'string' },
      badges_list: { type: 'json' },
      show_last_changed: { type: 'boolean' },
      hide_control: { type: 'boolean' },
      extra_data_template: { type: 'string' },
      extra_badge: { type: 'json' },
      stretch_slider: { type: 'boolean' },
      slider_theme: { type: 'json' },
      theme: { type: 'string' },
      confirm_controls: { type: 'boolean' },
      confirm_controls_show_lock: { type: 'boolean' },
      hide_in_default_view: { type: 'boolean' },
    };
    if (window.hassUtil.LOGIC_STATE_ATTRIBUTES) {
      Array.prototype.push.apply(
        window.hassUtil.LOGIC_STATE_ATTRIBUTES, Object.keys(customUiAttributes));
    }
    if (window.hassAttributeUtil.LOGIC_STATE_ATTRIBUTES) {
      Object.assign(window.hassAttributeUtil.LOGIC_STATE_ATTRIBUTES, customUiAttributes);
    }
  },

  updateConfigPanel() {
    if (!window.location.pathname.startsWith('/config')) return;
    const haPanelConfig = window.customUI.getElementHierarchy(document, [
      'home-assistant',
      'home-assistant-main',
      'partial-panel-resolver',
      'ha-panel-config']);
    if (!haPanelConfig) {
      // DOM not ready. Wait 1 second.
      window.setTimeout(window.customUI.updateConfigPanel, 1000);
      return;
    }
    const ironPages = window.customUI.lightOrShadow(haPanelConfig, 'iron-pages');
    if (!ironPages) return;
    const haConfigNavigation = window.customUI.getElementHierarchy(haPanelConfig, [
      'ha-config-dashboard',
      'ha-config-navigation']);
    if (!haConfigNavigation) return;
    if (ironPages.lastElementChild.tagName !== 'HA-CONFIG-CUSTOM-UI') {
      const haConfigCustomUi = document.createElement('ha-config-custom-ui');
      haConfigCustomUi.isWide = window.customUI.domHost(ironPages).isWide;
      haConfigCustomUi.setAttribute('page-name', 'customui');
      ironPages.appendChild(haConfigCustomUi);
      ironPages.addEventListener('iron-items-changed', () => {
        if (window.location.pathname.startsWith('/config/customui')) {
          ironPages.select('customui');
        }
      });
    }
    if (!haConfigNavigation.pages.some(conf => conf.domain === 'customui')) {
      haConfigNavigation.push('pages', {
        domain: 'customui',
        caption: 'Custom UI',
        description: 'Set UI tweaks.',
        loaded: true,
      });
    }
  },

  installStatesHook() {
    const homeAssistant = customElements.get('home-assistant');
    if (!homeAssistant || !homeAssistant.prototype._updateHass) return;
    const originalUpdate = homeAssistant.prototype._updateHass;
    homeAssistant.prototype._updateHass = function update(obj) {
      // Use named function to preserve 'this'.
      const { hass } = this;
      if (obj.states) {
        Object.keys(obj.states).forEach((key) => {
          const entity = obj.states[key];
          if (entity._cui_keep) return;
          const newEntity = window.customUI.maybeApplyTemplates(hass, obj.states, entity);
          if (hass.states && entity !== hass.states[key]) {
            // New state arrived. Put modified state in.
            obj.states[key] = newEntity;
          } else if (entity !== newEntity) {
            // It's the same state but contents changed due to other state changes.
            obj.states[key] = newEntity;
          }
        });
      }
      originalUpdate.call(this, obj);
    };
    const main = window.customUI.lightOrShadow(document, 'home-assistant');
    if (main.hass && main.hass.states) {
      main._updateHass({ states: main.hass.states });
    }
  },

  installPartialCards() {
    const partialCards = customElements.get('partial-cards');
    if (!partialCards || !partialCards.prototype._defaultViewFilter) return;
    partialCards.prototype._defaultViewFilter = (hass, entityId) => {
      if (hass.states[entityId].attributes.hidden) return false;
      const excludes = {};
      Object.values(hass.states).forEach((entity) => {
        if (entity.attributes && entity.attributes.hide_in_default_view) {
          const excludeEntityId = entity.entity_id;
          if (excludes[excludeEntityId]) return;
          excludes[excludeEntityId] = entity;
          if (entity.attributes.view) {
            Object.assign(
              excludes, window.HAWS.getViewEntities(hass.states, entity));
          }
        }
      });
      return !excludes[entityId];
    };
  },

  installHaStateLabelBadge() {
    const haStateLabelBadge = customElements.get('ha-state-label-badge');
    if (!haStateLabelBadge || !haStateLabelBadge.prototype.stateChanged) return;
    // Use named function to preserve 'this'.
    haStateLabelBadge.prototype.stateChanged = function update(stateObj) {
      // TODO: Call window.customUI.maybeChangeObject
      window.hassUtil.applyThemesOnElement(
        this,
        this.hass.themes || { default_theme: 'default', themes: {} },
        stateObj.attributes.theme || 'default');
      this.updateStyles();
      if (this.startInterval) {
        // Added on 19.1.18
        this.startInterval(stateObj);
      }
    };
  },

  installClassHooks() {
    if (window.customUI.classInitDone) return;
    window.customUI.classInitDone = true;
    window.customUI.installPartialCards();
    window.customUI.installStatesHook();
    window.customUI.installHaStateLabelBadge();
  },

  init() {
    if (window.customUI.initDone) return;
    window.customUI.installClassHooks();
    const main = window.customUI.lightOrShadow(document, 'home-assistant');
    if (!main.hass || !main.hass.states) {
      // Connection wasn't made yet. Try in 1 second.
      window.setTimeout(window.customUI.init, 1000);
      return;
    }
    window.customUI.initDone = true;

    window.customUI.useCustomizer();

    window.customUI.runHooks();
    window.addEventListener('location-changed', window.setTimeout.bind(null, window.customUI.runHooks, 100));
    /* eslint-disable no-console */
    console.log(`Loaded CustomUI ${window.customUI.VERSION}`);
    /* eslint-enable no-console */
  },

  runHooks() {
    window.customUI.fixGroupTitles();
    window.customUI.showVersion();
    window.customUI.updateAttributes();
    window.customUI.updateConfigPanel();
  },

  getName() {
    return window.localStorage.getItem('ha-device-name') || '';
  },

  setName(name) {
    window.localStorage.setItem('ha-device-name', name || '');
  },

  computeTemplate(template, hass, entities, entity, attributes, attribute, state) {
    const functionBody = (template.indexOf('return') >= 0) ? template : `return \`${template}\`;`;
    try {
      /* eslint-disable no-new-func */
      const func = new Function(
        'hass', 'entities', 'entity', 'attributes', 'attribute', 'state', functionBody);
      /* eslint-enable no-new-func */
      return func(hass, entities, entity, attributes, attribute, state);
    } catch (e) {
      /* eslint-disable no-console */
      if ((e instanceof SyntaxError) || e instanceof ReferenceError) {
        console.warn(`${e.name}: ${e.message} in template ${functionBody}`);
        return null;
      }
      /* eslint-enable no-console */
      throw e;
    }
  },
};

window.customUI.init();
</script>
<dom-module id="ha-config-custom-ui">
  <template>
    <style include="ha-style"></style>
    <app-header-layout has-scrolling-region="">
      <app-header slot="header" fixed="">
        <app-toolbar>
          <paper-icon-button icon="mdi:arrow-left" on-tap="_backTapped"></paper-icon-button>
          <div main-title="">Custom UI settings</div>
        </app-toolbar>
      </app-header>

      <ha-config-section is-wide="[[isWide]]">
        <paper-card heading="Device name">
          <div class="card-content">
            Set device name so that you can reference it in per-device settings
            <paper-input label="Name" value="{{name}}"></paper-input>
          </div>
        </paper-card>
      </ha-config-section>
    </app-header-layout>
  </template>
</dom-module>

<script>
class HaConfigCustomUi extends Polymer.Element {
  static get is() { return 'ha-config-custom-ui'; }

  static get properties() {
    return {
      isWide: Boolean,

      name: {
        type: String,
        observer: 'nameChanged',
      },
    };
  }

  ready() {
    super.ready();
    this.name = window.customUI.getName();
  }

  nameChanged(name) {
    window.customUI.setName(name);
  }

  _backTapped() {
    window.history.back();
  }
}
customElements.define(HaConfigCustomUi.is, HaConfigCustomUi);
</script>
<script>
/* eslint no-unused-vars: 0 */
class CuiBaseElement extends Polymer.Element {
  static get properties() {
    return {
      hass: Object,
      inDialog: {
        type: Boolean,
        value: false,
      },
      stateObj: Object,
      controlElement: String,
      extra: {
        type: Array,
        computed: 'computeExtra(hass, stateObj)',
      },
    };
  }

  computeExtra(hass, stateObj) {
    let extras = stateObj.attributes.extra_data_template;
    if (extras) {
      if (!Array.isArray(extras)) {
        extras = [extras];
      }
      return extras.map(extra => window.customUI.computeTemplate(
        extra,
        hass,
        hass.states,
        stateObj,
        stateObj.attributes,
        /* attribute= */ undefined,
        stateObj.state,
      )).filter(result => result !== null);
    }
    return [];
  }

  showLastChanged(stateObj, inDialog, extra) {
    if (inDialog) return true;
    if (extra.length) return false;
    return !!stateObj.attributes.show_last_changed;
  }

  hasExtra(extra) {
    return extra.length > 0;
  }
}
</script>
<!-- dynamic-element should be loaded syncronously so correct size can be measured on startup. --><script>
class DynamicElement extends Polymer.Element {
  static get is() { return 'dynamic-element'; }

  static get properties() {
    return {
      hass: Object,
      stateObj: Object,
      elementName: String,

      inDialog: {
        type: Boolean,
        value: false,
      },
    };
  }

  static get observers() {
    return [
      'observerFunc(hass, stateObj, elementName, inDialog)',
    ];
  }

  observerFunc(hass, stateObj, elementName, inDialog) {
    window.hassUtil.dynamicContentUpdater(
      this, elementName ? elementName.toUpperCase() : 'DIV',
      { hass, stateObj, inDialog });
  }
}
customElements.define(DynamicElement.is, DynamicElement);
</script>
<dom-module id="dynamic-with-extra">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-alignment iron-flex-factors"></style>
    <style>
      :host {
        display: inline-block;
      }
      .control-wrapper {
        margin: -4px -16px -4px 0;
        padding: 4px 16px;
      }
      ha-state-label-badge {
        margin-left: 8px;
      }
      dynamic-element {
        display: block;
        text-align: right;
      }
      #overlay {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        text-align: right;
      }
      #lock {
        margin-top: 8px;
        opacity: 0.3;
        margin-right: 7px;
      }
      #lock.ha-cover-controls {
        margin-right: 52px;
        background-color: white;
      }
      .extra {
        margin-bottom: -16px;
        --ha-label-badge-size: 36px;
        --ha-label-badge-font-size: 1.2em;
      }
      .state {
        @apply(--paper-font-body1);
        color: var(--primary-text-color);
        margin-left: 16px;
        text-align: right;
        line-height: 40px;
      }
    </style>
    <div class$="[[extraClass(extraObjVisible)]] horizontal layout">
      <template is="dom-if" if="[[extraObjVisible]]">
        <template is="dom-repeat" items="[[extraObj]]" on-dom-change="extraDomChanged">
          <ha-state-label-badge hass="[[hass]]" state="[[item]]"></ha-state-label-badge>
        </template>
      </template>
      <template is="dom-if" if="[[_showControl(inDialog, stateObj)]]">
        <template is="dom-if" if="[[controlElement]]">
          <div class="control-wrapper">
            <dynamic-element class="flex" state-obj="[[stateObj]]" hass="[[hass]]" element-name="[[controlElement]]"></dynamic-element>
            <template is="dom-if" if="[[isConfirmControls(stateObj)]]">
              <div id="overlay" on-tap="tapHandler">
                <template is="dom-if" if="[[stateObj.attributes.confirm_controls_show_lock]]">
                  <iron-icon id="lock" class$="[[controlElement]]" icon="mdi:lock-outline"></iron-icon>
                </template>
              </div>
            </template>
          </div>
        </template>
        <template is="dom-if" if="[[!controlElement]]">
          <div class="state">[[computeStateDisplay(stateObj)]]</div>
        </template>
      </template>
    </div>
  </template>
</dom-module>

<script>
class DynamicWithExtra extends (StateCardDisplay || Polymer.Element) {
  static get is() { return 'dynamic-with-extra'; }

  static get properties() {
    return {
      hass: Object,
      inDialog: {
        type: Boolean,
        value: false,
      },
      stateObj: Object,
      controlElement: String,
      extraObj: {
        type: Array,
        computed: 'computeExtra(hass, stateObj, _attached)',
      },
      _attached: Boolean,
      extraObjVisible: {
        type: Boolean,
        computed: 'computeExtraVisible(extraObj, inDialog)',
      },
    };
  }

  connectedCallback() {
    super.connectedCallback();
    this._attached = true;
  }

  disconnectedCallback() {
    this._isAttached = false;
    super.disconnectedCallback();
  }

  computeExtra(hass, stateObj, attached) {
    if (!stateObj.attributes.extra_badge || !attached) return [];
    let extraBadges = stateObj.attributes.extra_badge;
    if (!Array.isArray(extraBadges)) {
      extraBadges = [extraBadges];
    }
    return extraBadges.map((extraBadge) => {
      let result = null;
      if (extraBadge.entity_id && hass.states[extraBadge.entity_id]) {
        result = Object.assign({}, window.customUI.maybeChangeObject(
          this, hass.states[extraBadge.entity_id], this.inDialog,
          /* allowHidden= */false));
      } else if (extraBadge.attribute &&
                 stateObj.attributes[extraBadge.attribute] !== undefined) {
        result = {
          state: String(stateObj.attributes[extraBadge.attribute]),
          _domain: 'none',
          entity_id: null,
          attributes: { unit_of_measurement: extraBadge.unit },
        };
      }
      if (!result) return null;
      let blacklist = extraBadge.blacklist_states;
      if (blacklist) {
        if (!Array.isArray(blacklist)) {
          blacklist = [blacklist];
        }
        if (blacklist.some(v => RegExp(v).test(result.state.toString()))) {
          return null;
        }
      }
      result._entityDisplay = '';
      return result;
    }).filter(extraBadge => extraBadge != null);
  }

  computeExtraVisible(extraObj, inDialog) {
    if (inDialog || !extraObj) return false;
    return extraObj.length !== 0;
  }

  extraClass(extraObjVisible) {
    return extraObjVisible ? 'extra' : '';
  }

  _showControl(inDialog, stateObj) {
    if (inDialog) return true;
    return !stateObj.attributes.hide_control;
  }

  computeStateDisplay(stateObj) {
    if (window.hassUtil.computeStateState) {
      return window.hassUtil.computeStateState(stateObj);
    }
    // haLocalize removed in 0.61
    return super.computeStateDisplay(this.haLocalize || this.localize, stateObj);
  }

  isConfirmControls(stateObj) {
    return stateObj.attributes.confirm_controls ||
        stateObj.attributes.confirm_controls_show_lock;
  }

  tapHandler(e) {
    this.$$('#overlay').style.pointerEvents = 'none';
    const lock = this.$$('#lock');
    if (lock) {
      lock.icon = 'mdi:lock-open-outline';
      lock.style.opacity = '0.1';
    }
    window.setTimeout(() => {
      this.$$('#overlay').style.pointerEvents = '';
      if (lock) {
        lock.icon = 'mdi:lock-outline';
        lock.style.opacity = '';
      }
    }, 5000);
    e.stopPropagation();
  }

  applyThemes(hass, element, stateObj) {
    const themeName = stateObj.attributes.theme || 'default';
    window.hassUtil.applyThemesOnElement(
      element, hass.themes || { default_theme: 'default', themes: {} }, themeName);
  }

  extraDomChanged() {
    this.root.querySelectorAll('ha-state-label-badge')
      .forEach((elem) => {
        this.applyThemes(this.hass, elem, elem.state);
      });
  }
}
customElements.define(DynamicWithExtra.is, DynamicWithExtra);
</script>
<dom-module id="ha-themed-slider">
  <template>
    <style>
      :host {
        margin: var(--ha-themed-slider-margin, initial);
      }
      .disable-off-when-min {
        --paper-slider-pin-start-color:  var(--paper-slider-pin-color);
      }

      .disable-off-when-min.is-on {
        --paper-slider-knob-start-color: var(--paper-slider-knob-color);
        --paper-slider-knob-start-border-color: var(--paper-slider-knob-color);
      }
      paper-slider {
        margin: 4px 0;
        max-width: 100%;
        min-width: 100px;
        width: var(--ha-paper-slider-width, 200px);
      }
    </style>

    <paper-slider min="[[_themedMin]]" max="[[_computeAttribute(theme, &quot;max&quot;, max)]]" pin="[[_computeAttribute(theme, &quot;pin&quot;, pin)]]" class$="[[computeClass(theme, isOn, _themedMin)]]" value="[[value]]" on-change="valueChanged">
    </paper-slider>
  </template>
</dom-module>

<script>
class HaThemedSlider extends Polymer.Element {
  static get is() { return 'ha-themed-slider'; }

  ready() {
    super.ready();
    // If value was above 100 it wouldn't propagate to paper-slider while that had max=100
    // Force-change the value so that paper-slider will update itself.
    this.value = this.value + 1;
    this.value = this.value - 1;
    // Propagate the themed value upwards.
    this.disableOffWhenMin = !this._computeAttribute(this.theme, 'off_when_min', !this.disableOffWhenMin);
    this.computeEnabledThemedReportWhenNotChanged(this.theme, this.disableReportWhenNotChanged);
  }

  static get properties() {
    return {
      min: {
        type: Number,
        value: 0,
      },
      max: {
        type: Number,
        value: 100,
      },
      pin: {
        type: Boolean,
        value: false,
      },
      isOn: {
        type: Boolean,
        value: false,
      },
      disableOffWhenMin: {
        type: Boolean,
        value: false,
        notify: true,
      },
      disableReportWhenNotChanged: {
        type: Boolean,
        value: false,
      },

      theme: Object,
      value: {
        type: Number,
        notify: true,
      },
      _themedMin: {
        type: Number,
        computed: '_computeAttribute(theme, "min", min)',
      },
    };
  }

  static get observers() {
    return [
      'computeEnabledThemedReportWhenNotChanged(theme, disableReportWhenNotChanged)',
    ];
  }

  computeEnabledThemedReportWhenNotChanged(theme, disableReportWhenNotChanged) {
    this._enabledThemedReportWhenNotChanged = this._computeAttribute(
      theme, 'report_when_not_changed', !disableReportWhenNotChanged);
  }

  _computeAttribute(theme, attr, def) {
    if (theme) {
      if (attr in theme) {
        return theme[attr];
      }
    }
    return def;
  }

  computeClass(theme, isOn, themedMin) {
    let result = '';
    if (isOn) {
      result += 'is-on ';
    }
    if (this._computeAttribute(theme, 'off_when_min', !this.disableOffWhenMin) || themedMin === 0) {
      // If offWhenMin is enabled don't customize.
      return '';
    }
    return `${result}disable-off-when-min`;
  }

  valueChanged(ev) {
    if (!this._enabledThemedReportWhenNotChanged && this.value === ev.target.value) {
      ev.stopPropagation();
      return;
    }
    this.value = ev.target.value;
  }
}
customElements.define(HaThemedSlider.is, HaThemedSlider);
</script>
<dom-module id="state-card-with-slider">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-alignment iron-flex-factors"></style>
    <style>
      #container {
        position: relative;
      }
      .second-line, .state-and-toggle, .state-info {
        max-width: 100%;
      }
      .nowrap .state-and-toggle {
        overflow: hidden;
        flex-grow: 0;
      }
      .nowrap .second-line {
        overflow: hidden;
      }

      .second-line {
        padding-top: 20px;
        padding-bottom: 16px;
        margin-top: -20px;
        margin-bottom: -16px;
      }
      .stretch .second-line, .stretch ha-themed-slider {
        width: 100%;
        --ha-paper-slider-width: 100%;
      }
      .nowrap .state-info {
        min-width: initial;
      }
      ha-themed-slider, .top-wrapper {
        min-width: 100px;
        max-width: 100%;
      }
      .top-wrapper.stretch {
        display: block;
      }

      .hidden {
        display: none;
      }
    </style>

    <div id="container" class$="horizontal layout flex top-wrapper [[_computeWrapClass(mode, stretchSlider, lineTooLong, inDialog)]]">
      <div class="horizontal layout justified flex-auto state-and-toggle">
        <state-info class="state-info" state-obj="[[stateObj]]" in-dialog="[[showLastChanged(stateObj, inDialog, extra)]]" secondary-line$="[[hasExtra(extra)]]">
          <template is="dom-repeat" items="[[extra]]">
            <div>[[item]]</div>
          </template>
        </state-info>
        <template is="dom-if" if="[[breakSlider]]" class="hidden">
          <dynamic-with-extra hass="[[hass]]" state-obj="[[stateObj]]" control-element="[[controlElement]]" in-dialog="[[inDialog]]"></dynamic-with-extra>
        </template>
      </div>
      <template is="dom-if" if="[[showSlider]]" restamp="">
        <div class="horizontal layout flex-auto end-justified second-line">
          <ha-themed-slider id="slider" max="[[max]]" min="[[min]]" theme="[[stateObj.attributes.slider_theme]]" is-on="[[isOn(stateObj, nameOn)]]" value="{{sliderValue}}" disable-off-when-min="{{disableOffWhenMin}}" on-change="sliderChanged" on-tap="stopPropagation">
          </ha-themed-slider>
          <template is="dom-if" if="[[!breakSlider]]">
            <dynamic-with-extra hass="[[hass]]" state-obj="[[stateObj]]" control-element="[[controlElement]]" in-dialog="[[inDialog]]"></dynamic-with-extra>
          </template>
        </div>
      </template>
    </div>
  </template>
</dom-module>

<script>
class StateCardWithSlider extends Polymer.mixinBehaviors(
  [Polymer.IronResizableBehavior], CuiBaseElement) {
  static get is() { return 'state-card-with-slider'; }

  static get properties() {
    return {
      domain: String,
      serviceMin: String,
      serviceMax: String,
      valueName: String,
      setValueName: String,
      nameOn: { type: String, value: 'on' },
      min: { type: Number, value: 0 },
      max: { type: Number, value: 255 },

      sliderValue: {
        type: Number,
        value: 0,
      },
      disableOffWhenMin: Boolean,
      mode: String,
      stretchSlider: {
        type: Boolean,
        value: false,
      },
      breakSlider: {
        type: Boolean,
        value: false,
      },
      hideSlider: {
        type: Boolean,
        value: false,
      },
      lineTooLong: {
        type: Boolean,
        value: false,
      },
      minLineBreak: Number,
      maxLineBreak: Number,
      showSlider: {
        type: Number,
        computed: '_showSlider(inDialog, stateObj, hideSlider)',
      },
    };
  }

  ready() {
    super.ready();
    this._onIronResize = this._onIronResize.bind(this);
  }

  connectedCallback() {
    super.connectedCallback();
    this.addEventListener('iron-resize', this._onIronResize);
    this._waitForLayout();
  }

  disconnectedCallback() {
    this.removeEventListener('iron-resize', this._onIronResize);
    super.disconnectedCallback();
  }

  static get observers() {
    return [
      'stateObjChanged(stateObj, nameOn, valueName)',
    ];
  }

  _waitForLayout() {
    this._setMode();
    if (this._frameId) return;
    this.readyToCompute = false;
    this._frameId = window.requestAnimationFrame(() => {
      this._frameId = null;
      this.readyToCompute = true;
      this._onIronResize();
    });
  }

  _setMode() {
    const obj = {
      hideSlider: this.mode === 'hide-slider' && this.lineTooLong,
      breakSlider:
           (this.mode === 'break-slider' || this.mode === 'hide-slider') &&
           this.lineTooLong,
    };
    if (!this.showSlider) {
      obj.breakSlider = true;
    }
    this.setProperties(obj);
  }

  _onIronResize() {
    if (!this.readyToCompute) return;
    if (this.mode === 'no-slider') {
      this.setProperties({
        hideSlider: true,
        breakSlider: true,
      });
      return;
    }
    const prevBreakSlider = this.breakSlider;
    const prevHideSlider = this.hideSlider;
    this.setProperties({
      lineTooLong: false,
      hideSlider: false,
      breakSlider: false,
    });
    const { container } = this.$;
    const containerWidth = container.clientWidth;
    if (containerWidth === 0) return;
    if (containerWidth <= this.minLineBreak) {
      this.lineTooLong = true;
    } else if (containerWidth >= this.maxLineBreak) {
      this.lineTooLong = false;
    } else {
      if (prevHideSlider && this.mode === 'hide-slider') {
        // We need to unhide the slider in order to recalculate height.
        this._waitForLayout();
        return;
      }
      const containerHeight = container.clientHeight;
      const stateHeight = this.$$('.state-info').clientHeight;
      this.lineTooLong = containerHeight > stateHeight * 1.5;
      if (this.lineTooLong) {
        this.minLineBreak = containerWidth;
      } else if (!prevBreakSlider) {
        this.maxLineBreak = containerWidth;
      }
    }
    this._setMode();
  }

  _computeWrapClass(mode, stretchSlider, lineTooLong, inDialog) {
    if (inDialog) {
      return '';
    }
    if (mode === 'single-line') {
      return 'nowrap';
    }
    if (stretchSlider && lineTooLong) {
      return 'stretch wrap';
    }
    return 'wrap';
  }

  _showSlider(inDialog, stateObj, hideSlider) {
    if (inDialog || hideSlider) {
      return false;
    }
    return true;
  }

  sliderChanged(ev) {
    const value = parseInt(ev.target.value, 10);
    const param = { entity_id: this.stateObj.entity_id };
    if (Number.isNaN(value)) return;
    let target = this.$$('#slider');
    if (ev.target !== target) {
      // No Shadow DOM - we have access to original target.
      ({ target } = ev);
    } else if (ev.path) {
      [target] = ev.path;
    } else if (ev.composedPath) {
      [target] = ev.composedPath();
    }
    if (value === 0 || (value <= target.min && !this.disableOffWhenMin)) {
      this.hass.callService(this.domain, this.serviceMin, param);
    } else {
      param[this.setValueName || this.valueName] = value;
      this.hass.callService(this.domain, this.serviceMax, param);
    }
  }

  stateObjChanged(stateObj, nameOn, valueName) {
    if (this.isOn(stateObj, nameOn)) {
      this.sliderValue = stateObj.attributes[valueName];
    } else {
      this.sliderValue = 0;
    }
    if (stateObj) {
      const obj = {
        minLineBreak: 0,
        maxLineBreak: 999,
        hideSlider: false,
        breakSlider: false,
        lineTooLong: false,
        mode: stateObj.attributes.state_card_mode,
        stretchSlider: !!stateObj.attributes.stretch_slider,
      };
      this.setProperties(obj);
      this._waitForLayout();
    }
  }

  isOn(stateObj, nameOn) {
    return stateObj && (!nameOn || stateObj.state === nameOn);
  }

  stopPropagation(ev) {
    ev.stopPropagation();
  }
}
customElements.define(StateCardWithSlider.is, StateCardWithSlider);
</script>
<dom-module id="state-card-without-slider">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-alignment"></style>
    <style>
      #container {
        position: relative;
      }
    </style>

    <div id="container" class="horizontal layout justified">
      <state-info class="state-info" state-obj="[[stateObj]]" in-dialog="[[showLastChanged(stateObj, inDialog, extra)]]" secondary-line$="[[hasExtra(extra)]]">
        <template is="dom-repeat" items="[[extra]]">
          <div>[[item]]</div>
        </template>
      </state-info>
      <dynamic-with-extra hass="[[hass]]" state-obj="[[stateObj]]" control-element="[[controlElement]]" in-dialog="[[inDialog]]">
      </dynamic-with-extra>
    </div>
  </template>
</dom-module>

<script>
class StateCardWithoutSlider extends CuiBaseElement {
  static get is() { return 'state-card-without-slider'; }
}
customElements.define(StateCardWithoutSlider.is, StateCardWithoutSlider);
</script>
<script>
{
  const SHOW_LAST_CHANGED_BLACKLISTED_CARDS = ['configurator'];
  const DOMAIN_TO_SLIDER_SUPPORT = {
    light: 1, // SUPPORT_BRIGHTNESS
    cover: 4, // SUPPORT_SET_POSITION
    climate: 1, // SUPPORT_TARGET_TEMPERATURE
  };
  const TYPE_TO_CONTROL = {
    toggle: 'ha-entity-toggle',
    display: '',
    cover: 'ha-cover-controls',
  };
  class StateCardCustomUi extends Polymer.Element {
    static get is() { return 'state-card-custom-ui'; }

    static get properties() {
      return {
        hass: Object,

        inDialog: {
          type: Boolean,
          value: false,
        },

        stateObj: Object,
      };
    }

    static get observers() {
      return [
        'inputChanged(hass, inDialog, stateObj)',
      ];
    }

    connectedCallback() {
      super.connectedCallback();
      const container = this.parentNode.parentNode;
      if (container.tagName === 'DIV' &&
          (container.classList.contains('state') || container.classList.contains('child-card'))) {
        this._container = container;

        // Since this doesn't actually change the background - no need to clear it.
        container.style.setProperty(
          'background-color', 'var(--paper-card-background-color, inherit)');

        // Polyfill 'updateStyles'.
        if (!container.updateStyles) {
          container.updateStyles = (styles) => {
            Object.keys(styles).forEach((key) => {
              container.style.setProperty(key, styles[key]);
            });
          };
        }
      }
      this._isAttached = true;
      this.inputChanged(this.hass, this.inDialog, this.stateObj);
    }

    disconnectedCallback() {
      this._isAttached = false;
      if (this._container) {
        this._container.updateStyles({ display: '', margin: '', padding: '' });
        window.hassUtil.applyThemesOnElement(
          this._container, this.hass.themes || { default_theme: 'default', themes: {} }, 'default');
        this._container = null;
      }
      super.disconnectedCallback();
    }

    badgeMode(hass, stateObj, domain) {
      const states = [];
      if (domain === 'group') {
        stateObj.attributes.entity_id.forEach((id) => {
          const state = hass.states[id];
          if (!state) {
            /* eslint-disable no-console */
            console.warn(`Unknown ID ${id} in group ${stateObj.entity_id}`);
            /* eslint-enable no-console */
            return;
          }
          if (!stateObj.attributes.badges_list ||
              stateObj.attributes.badges_list.includes(state.entity_id)) {
            states.push(window.customUI.maybeChangeObject(
              this, state, false /* inDialog */, false /* allowHidden */));
          }
        });
      } else {
        states.push(stateObj);
        if (this._container) {
          this._container.style.display = 'inline-block';
          const params = { display: 'inline-block' };
          if (this._container.classList.contains('state')) {
            params.margin = 'var(--ha-badges-card-margin, 0 -6px)';
          }
          this.updateStyles(params);
        }
      }
      window.hassUtil.dynamicContentUpdater(
        this,
        'HA-BADGES-CARD',
        { hass, states });
      if (this._container) {
        this._container.updateStyles({
          width: 'var(--ha-badges-card-width, initial)',
          'text-align': 'var(--ha-badges-card-text-align, initial)',
        });
      }
      this.lastChild.style.fontSize = '85%';

      // Since this variable only affects badges mode - no need to clean it up.
      this.style.setProperty('--ha-state-label-badge-margin-bottom', '0');
    }

    cleanBadgeStyle() {
      if (this._container) {
        this._container.updateStyles({
          display: '',
          width: '',
          'text-align': '',
        });
      }
      this.updateStyles({ display: '', margin: '' });
    }

    applyThemes(hass, modifiedObj) {
      let themeTarget = this;
      let themeName = 'default';
      if (this._container) {
        themeTarget = this._container;
      }
      if (modifiedObj.attributes.theme) {
        themeName = modifiedObj.attributes.theme;
      }
      window.hassUtil.applyThemesOnElement(
        themeTarget, hass.themes || { default_theme: 'default', themes: {} }, themeName);
    }

    maybeHideEntity(modifiedObj) {
      if (!modifiedObj) {
        if (this.lastChild) {
          this.removeChild(this.lastChild);
        }
        if (this._container) {
          this._container.updateStyles({ margin: '0', padding: '0' });
        }
        return true;
      }
      if (this._container) {
        this._container.updateStyles({ margin: '', padding: '' });
      }
      return false;
    }

    sliderEligible_(domain, obj, inDialog) {
      if (inDialog) return false;
      return DOMAIN_TO_SLIDER_SUPPORT[domain] &&
        (DOMAIN_TO_SLIDER_SUPPORT[domain] & obj.attributes.supported_features) &&
        obj.attributes.state_card_mode && obj.attributes.state_card_mode !== 'no-slider';
    }

    inputChanged(hass, inDialog, stateObj) {
      if (!stateObj || !hass || !this._isAttached) return;
      const domain = window.hassUtil.computeDomain(stateObj);
      const modifiedObj = window.customUI.maybeChangeObject(
        this, stateObj, inDialog, true /* allowHidden */);

      if (this.maybeHideEntity(modifiedObj)) return;

      this.applyThemes(hass, modifiedObj);

      if (!inDialog && modifiedObj.attributes.state_card_mode === 'badges') {
        this.badgeMode(hass, modifiedObj, domain);
        return;
      }
      this.cleanBadgeStyle();

      const params = {
        hass,
        stateObj: modifiedObj,
        inDialog,
      };
      const stateCardType = window.hassUtil.stateCardType(hass, stateObj);
      let customStateCardType;
      const secondaryStateCardType = modifiedObj.attributes.state_card_custom_ui_secondary;

      if (domain === 'light' && this.sliderEligible_(domain, modifiedObj, inDialog)) {
        Object.assign(params, {
          controlElement: 'ha-entity-toggle',
          serviceMin: 'turn_off',
          serviceMax: 'turn_on',
          valueName: 'brightness',
          domain,
        });
        customStateCardType = 'state-card-with-slider';
      } else if (domain === 'cover' && this.sliderEligible_(domain, modifiedObj, inDialog)) {
        Object.assign(params, {
          controlElement: 'ha-cover-controls',
          max: 100,
          serviceMin: 'close_cover',
          serviceMax: 'set_cover_position',
          setValueName: 'position',
          valueName: 'current_position',
          nameOn: 'open',
          domain,
        });
        customStateCardType = 'state-card-with-slider';
      } else if (domain === 'climate' && this.sliderEligible_(domain, modifiedObj, inDialog)) {
        Object.assign(params, {
          controlElement: 'ha-climate-state',
          min: modifiedObj.attributes.min_temp || -100,
          max: modifiedObj.attributes.max_temp || 200,
          serviceMin: 'set_temperature',
          serviceMax: 'set_temperature',
          valueName: 'temperature',
          nameOn: '',
          domain,
        });
        customStateCardType = 'state-card-with-slider';
      } else if (TYPE_TO_CONTROL[stateCardType] !== undefined) {
        params.controlElement = TYPE_TO_CONTROL[stateCardType];
        customStateCardType = 'state-card-without-slider';
      } else if (modifiedObj.attributes.show_last_changed &&
                 !SHOW_LAST_CHANGED_BLACKLISTED_CARDS.includes(stateCardType)) {
        params.inDialog = true;
      }
      if (modifiedObj.state === 'unavailable') {
        params.controlElement = '';
      }

      window.hassUtil.dynamicContentUpdater(
        this,
        (secondaryStateCardType || customStateCardType || `STATE-CARD-${stateCardType}`).toUpperCase(),
        params);
    }
  }
  customElements.define(StateCardCustomUi.is, StateCardCustomUi);
}
</script></div>